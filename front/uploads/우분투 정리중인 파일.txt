
현재 디렉토리 확인
	- pwd : 현재 디렉토리의 경로 출력

디렉토리 이동
	- cd /home , cd /Users/tiger/new_folder : 디렉토리 이동
	- cd .. : 상위 디렉토리 이동 -> 이전 디렉토리로 이동
	- cd ~ : 홈 디렉토리로 이동

디렉토리 생성
	- mkdir 이름: 디렉토리 생성

빈 파일 생성
	- touch 이름.txt : 빈 파일 생성

파일 및 디렉토리 보기
	- ls : 현재 디렉토리의 파일과 디렉토리 보기
	- ls -l : 상세한 정보를 포함하여 리스트를 출력
	- ls -a : 숨겨진 파일 포함해서 모두 출력

디렉토리 및 파일 복사
	- cp 원본파일 대상경로 : cp example.txt /home/user - 파일을 해당 경로로 복사합니다.
	- cp -r 원본디렉토리 대상경로 : cp -r /home/users/new_folder /home/users - 디렉토리를 해당 경로로 복사합니다.

디렉토리 및 파일 이동
	- mv 원본파일 대상경로 : cp example.txt /home/user -> 파일을 해당 경로로 이동합니다.
	- mv -r 원본디렉토리 대상경로 : cp -r /home/users/new_folder /home/users - 디렉토리를 해당 경로로 이동합니다.

디렉토리 및 파일 삭제
	- rm 파일이름 : 해당 파일을 삭제합니다
	- rm -r 디렉토리 이름 : 해당 디렉토리를 삭제합니다.

파일 내용 보기
	- cat 파일이름 : 파일이름에 해당되는 파일 내용을 출력합니다.

파일 단위 출력
	- less 파일이름 : 파일이름에 해당되는 파일을 페이지 단위로 볼 수 있습니다 (q로 종료)

파일 일부 출력
	- head -n 줄수 파일이름 : 파일의 처음 몇 줄을 출력합니다.
	- tail -n 줄수 파일이름 : 파일의 뒤 몇줄을 출력합니다.

파일 수정
	- nano 파일이름 : 파일의 수정할 수 있다 - ctrl +o를 누르면 저장, 엔터를 누르면 편집 모드 탈출, ctrl + x를 누르면 탈출
				안에 있는 내용을 토대로 버퍼를 저장할 수 있다. -- 자세히는 모르겠다
	- vi 파일이름 : 파일을 생성과 파일 편집이 가능하다 ESC 편집 모드 탈출 :wq 저장후 닫기, i 편집 insert모드, :q! 강제 탈출 

권한 확인
	- ls -l 파일/디렉토리이름 : 각 파일의 권한 확인

권한 변경
	- chmod 권한 파일/디렉토리이름 : chmod 755 example.txt 읽기 쓰기 실행권한 설정
	- 숫자 자리의 의미
		첫 번째 자리 파일 소유자 (user u) : 생성한 본인(사용자)
		두 번째 자리 소유 그룹의 권한 (group g) : 파일을 생성한 사용자와 동일한 그룹에 속한 사용자
		세 번째 자리 다른 모든 사용자의 권한 (others, o) : 소유자 X, 그룹에 속하지 않은 모든 외부 사용자
		네 번째 자리 특수 권한 SUID(Set User ID) : 4로 표시, 파일 실행 시 파일 소유자 권한으로 실행
							SGID(Set Group ID) : 2로 표시, 실행 시 파일 소유 그룹 권한으로 실행
							Sticky Bit : 1로 표시, 디렉토리 내 파일 소유자만 삭제 가능하도록 제한
	-권한 숫자의 의미
		읽기 권한(r) : 4
		쓰기 권한(w) : 2
		실행 권한(x) : 1
		권한 없음 : 0
		- 755의 해석 : 7 = 읽기(4) + 쓰기(2) + 실행(1) (rwx)
					  5 = 읽기(4) + 실행(1) (r-x)
					  5 = 읽기(4) + 실행(1) (r-x) 
		- 만약 외부사용자 읽기 권한만 주어질 때
					  7 = 읽기(4) + 쓰기(2) + 실행(1) (rwx)
					  5 = 읽기(4) + 실행(1) (r-x)
					  4 = 읽기(4) (r--)
		- 특수 권한 추가 시 - 4755
		
파일 검색
	- find 경로 -name 파일이름 : 파일 이름으로 검색
	- grep 검색어 파일이름 : grep "hello" example.txt - 파일 내용으로 검색
	
파일 크기와 디스크 사용량 확인
	- du -sh 경로 : 해당 경로의 디렉토리 또는 파일 총 용량을 표시 (-s 요약, -h 읽기 쉬운 형식으로 출력?)
	- df -h : 파일 시스템의 사용 가능한 전체 디스크 공간 확인

파일 압축 및 해제
	- tar -czvf archive.tar.gz 디렉토리명 : 디렉토리를 tar.gz형식으로 압축
	- tar -xzvf archive.tar.gz : tar.gz 파일을 압축 해제
	- zip -r archive.zip 디렉토리명 : 디렉토리를 zip형식으로 압축
	- unzip archive.zip : zip파일을 해제

파일 및 디렉토리 권한 보기 및 변경
	- chmod -R 권한 디렉토리명 : 디렉토리와 내부파일에 대해 재귀적으로 권한 설정
	- chown 사용자이름:그룹이름 파일/디렉토리 : 파일이나 디렉토리의 소유자 및 그룹 변경

프로세스 관리
	- ps aux : 현재 실행 중인 프로세스 목록을 확인
	- kill -9 PID : 특정 프로세스를 강제 종료(PID는 프로세스 ID)

네트워크 관련 명령어
	- ping 도메인/ip : 네트워크 연결 확인
	- netstat -tuln : 현재 열려 있는 네트워크 포트 확인

확인 변수 확인 및 설정
	- echo $VARIABLE_NAME : 환경 변수 값 확인
	- export VARIABLE_NAME=값 : 환경 변수 설정(세션에만 적용)

파일 권한 설명에 권한 문자열 추가
	- rwxr-xr-- : 문자열을 통한 파일의 권한 표현을 설명에 추가하면 더 이해하기 쉬워짐?
	
cpu 관련
	- top : cpu와 관련된 정보를 볼 수 있다
	왠만해서 하지 말자

c 언어 컴파일 관련
	sudo apt update
	sudo apt install gcc
	
	- touch로 파일 생성 (hello.c) 형식
	- nano로 파일 내용 c형식으로 추가
	- gcc hello.c -o hello로 컴파일
	- ./hello로 컴파일 된 파일 실행
	
포트 관련
	- sudo lsof -i :포트번호 : 관련된 포트가 실행이 되어있는지 확인 할 수 있다
	- sudo kill -9 pid번호 : 관련된 포트의 pid번호로 정지시킬 수 있다
	- sudo ss -tuln | grep LISTEN : 실행 중인 포트 번호를 확인 할 수 있다.
			
			sudo를 포함할 시에 루트 권한이 필요한 모든 포트를 확인 할 수 있다.
			ss는 네트워크 소켓과 관련된 내용을 확인 할 때는 명령어다
			t : TCP 소켓을 보여줌
			u : UDP 소켓을 보여줌
			l : 현재 listening 상태의 소켓만 표시합니다. -> 외부 연결을 수신할 준비가 된 소켓만 확인 가능
			n : 포트와 ip 주소를 숫자로 표시합니다. -> 포트 번호가 80이면 http대신 80을 보여줌
	
jenv 추가
	- sudo apt install openjdk-11-jdk : java 버전 추가
	- jenv add /usr/lib/jvm/java-11-openjdk-amd64 : jenv 추가
	- jenv versions : 버전 확인
	- jenv global 11.0 : 전역 버전 변경
	
/*************************************************************/
/                 수민이 형책 우분투 리눅스                       /
/*************************************************************/

단어 지우기
	- ctrl + w
	
행 지우기
	- ctrl + u

ls 명령어
	- ls -a /tmp : 명령, 옵션, 인자 - a는 all의 약자 /tmp는 리눅스 시스템에서 임시 파일을 저장하는 디렉토리

clear - 화면을 지운다
date - 날짜와 시간 출력
man 명령어 - 해당 명령 사용법을 화면에 출력한다
passwd - 사용자 계정의 비밀번호를 변경한다
exit - 터미널을 종료한다

chsh - 사용자 로그인 셸을 바꾼다...? - 왜 필요한지는 아직 모르겠음
printf - 자료를 형식화하여 화면에 출력한다
		printf "%d + %d = %d\n" 10 10 20 => 10 + 10 = 20

특수문자 -
		* : 임의의 문자열을 나타내는 특수문자로 0개 이상의 문자로 대채된다. -> 여러파일의 이름을 나열할 때 파일명을 간단히 표시하는 데 주로 사용된다.
		?, [] : 모두 하나의 문자를 나타내는데 사용된다. -> ls tes?.txt : t다음 임의의 한문자를 나타낸다 ->ls [A-Za-z]*[0-9] : 영문자로 시작하고 숫자로 끝나는 모든 수
		~, - : 디렉터리를 나타내는 특수문자 -> -는 이전 작업 디렉토리로 이동, ~홈 디렉토리를 의미한다.
		;, | : 명령과 명령을 연결한다. -> ;은 왼쪽부터 차례대로 명령을 실행한다, |은 왼쪽 명령의 실행 결과를 오른쪽 명령의 입력으로 전달한다.
		'',"" : 문자를 감싸서 문자열을 만든다 -> ''는 모든 문자열을 , ""는 $,`,\를 제외한 모든 특수문자를 일반 문자로 간주한다. echo 'SHELL'로 테스트해보면 감이 온다
		`` : ``로 감싸진 문자열을 명령으로 해석해서 실행 시킨다. -> echo "today is `date`"
		\ : 특수문자 바로 앞에 사용되며 해당 특수문자의 효과를 없애고 일반 문자처럼 처리한다? -> 잘 모르겠지만 문자처럼 취급되서 t\*은 't*'취급으로 바뀐다. -> printf읜 \n은 뭐지?
		>,<,>> : 입출력의 방향을 바꾸는 특수문자이다 -> ls -l > res : ls -l의 결과를 res파일에 저장한다.
		
파일 덮어씌우기 		
	 > : 파일을 덮어 씌운다 -> echo "덮어씌우기" > test.txt : test.txt에 기존 데이터를 없애고 "덮어씌우기"를 덮어씌운다.
	 set -o noclobber : 덮어씌우기 방지
	 set +o noclobber : 덮어씌우기 방지 해제
	 >> : 파일에 내용을 추가한다 -> 파일 내용의 끝에 명령의 실행 결과를 넣는다
	 2> : 표준 오류 메시지를 파일에 저장한다 -> 명령 2> 파일
	 포준 출력과 포준 오류를 한 파일로 리다이렉트하기
			-- ls . /abc > test.txt 2>&1  ---> 모르겠다

환경변수와 셸변수
	set : 환경변수와 셸변수를 출력한다.
	env : 환경변수를 출력한다  ---> 둘 다 출력하지 말자 너무 길다

주요 셸 환경 변수
	환경변수   :    의미
	
	HISTSIZE : 히스토리 저장 크기
	HOME     : 사용자 홈 디렉터리의 절대 경로
	LANG     : 사용하는 언어
	LOGNAME  : 사용자 계정 이름
	PATH     : 명령을 탐색할 경로
	PWD      : 작업 디렉터리의 절대 경로
	SHELL    : 로그인 셸
	
	echo &HISTSIZE : 특정 변수 출력하기

셸 변수와 환경 변수 설정하기
	변수명=문자열 : SOME=test -> 변수명과문자열 사이에 공백 X 
	환경 변수 설정하기 : export 명령어 -> export [옵션]=[셸 변수], export, export SOME, export SOME=test
	export -n 명령어 : 환경변수로 설정했던 명령어를 다시 셸 변수로 바꾼다
	변수 해제 : unset -> unset 변수명
	--- 심신미약이다 알아서 알아서해라

에일리어스(별명)
	- alias 이름='별명' : 그냥 alias를 치면 현재 설정되어 있는 별명이 나온다, = 공백 X
	- unalias 이름 : 해당 이름의 내용을 제거한다.
	- 나름 유용하다 -> alias rm='rm -i'를 할 시에 rm에 제거를 계속 물어보게 된다.

history : 사용자가 로그인 후 사용한 명령어를 볼 수 있다. -> 명령어는 임시 버퍼에 저장되며 이를 다시 불러올 수 있다, 셸명령어로 출력한다.
	히스토리로 저장되어 있는 명령어를 다시 할 수 있다.
		!! : 바로 직전에 실행된 명령어를 재실행한다.
		!번호 : 히스토리에서 해당 번호의 명령을 재실행한다.
		!문자열 : 히스토리에서 해당 문자열로 시작하는 마지막 명령을 실행한다.
		
	히스토리 저장하기 : more !/.bash_history : 사용자가 입력한 명령의 목록을 사용자 홈 디렉터리 아래의 숨김파일인 .bash_history에 저장한다.

프롬프트 : 이해 안되니 나중에 찾아보기
(echo $PS1 : ps1의 현재 설정 값 확인

이스케이프 문자 : 너무 많아 나중에 찾아봐)

사용자 환경 설정
	~/.profile      : 경로 추가 등 사용자가 정의하는 환경을 설정한다. , .bashrc 파일이 있으면 실행
	~/.bashrc       : 히스토리의 크기를 설정한다, 기본 에일리어스나 함수 등을 설정한다.
	추가적으로 환경 설정하는 부분
		- vi 혹은 nano로 .bash_aliases 를 만든다 (이름은 자기 마음대로)
		- source혹은 .으로 환경 설정 파일 적용 : . .bash_aliases (혹은 source .bash_aliases)

umask : 마스크인데 딱히 중요하지는 않는 듯 , 현재 기본 접근 권한을 변경하거나 그럴 때 사용함

프로세스 종류 
	- 데몬 프로세스 : 시스템에서 백그라운드로 실행되며 특정 작업이나 서비스를 지속적으로 제공하는 프로세스
	- 고아 프로세스 : 부모 프로세스가 종료되어, init 프로세스가 대신 관리하는 프로세스
	- 좀비 프로세스 : 종료된 후에도 부모 프로세스가 종료 상태를 수거하지 않아 프로세스 테이블에 남아 있는 프로세스
	
프로세스 목록 보기
	- ps [옵션] :
		유닉스 -e : 시스템에서 실행 중인 모든 프로세스의 정보
			  -f : 프로세스의 자세한 정보를 출력
			  -u uid : 특정 사용자에 대한 모든 프로세스의 정보를 출력
			  -p pid : pid로 지정한 특정 프로세스의 정보를 출력
		BSD   -a : 터미널에서 실행한 프로세스의 정보를 출력
			  -u : 프로세스 소유자 이름, CPU 사용량, 메모리 사용량 등 상세 정보 출력			  
			  -x : 시스템에서 실행 중인 모든 프로세스의 정보를 출력
		GNU	  --pid PID 목록: 목록으로 지정한 특정 PID의 정보를 출력
		
		예 : ps   ps -ef   ps aux
		
		우분투는 위 세가지 옵션을 지원한다고 한다

		ps -f의 출력 정보
			- UID   : 프로세스를 실행한 사용자 ID
			- PID   : 프로세스 번호
			- PPID  : 부모 프로세스 번호
			- C     : CPU 사용량(% 값)
			- STIME : 프로세스의 시작 날짜나 시간
			- TTY   : 프로세스가 실행된 터미널의 종류와 번호
			- TIME  : 프로세스 실행 시간
			- CMD   : 실행되고 있는 프로그램의 이름
		
		ps -au의 출력 정보
			- USER  : 사용자 계정 정보
			- %CPU  : 퍼센트로 표시한 CPU 사용량
			- %MEN  : 퍼센트로 표시한 물리적 메모리 사용량
			- VSL   : 사용 중인 가상 메모리의 크기(KB)
			- RSS   : 사용 중인 물리적 메모리의 크기(KB)
			- START : 프로세스 시작 시간
		ps -ef의 출력 특이점
			- TTY에서 ?인 프로세스는 사용자 ID root이다
		
		프로세스 검색의 경우
			ps -ef | grep 검색어 : grep를 사용해서 검색을 하자
			아니면 pgrep를 통해서 옵션 등을 넣어 검색 할 수 있다. (예 : pgrep -x bash 등)
				
		프로세스 종료
			- SIGHUP  : 1  : 종료 - 터미널과의 연결이 끊어졌을 때 발생
			- SIGINT  : 2  : 종료 - 인터럽트로 사용자가 컨트롤 + c를 입력하면 발생
			- SIGQUT  : 3  : 종료, 코어덤프 - 종료 신호로 사용자가 컨트롤 + \을 입력하면 발생
			- SIGKILL : 9  : 종료 - 이 시그널을 받은 프로세스는 강제로 종료된다. 무시 X
			- SIGALRM : 14 : 종료 - 알람에 의해 발생
			- SIGTERM : 15 : 종료 - kill 명령이 보내는 기본 시그널
			
			예 : kill [-시그널] PID, kill 1001, kill -9 1001, kill -15 1001

		top 302p 수민이 형에게 부탁 바람


apt-cache : APT캐시에서 정보를 검색하여 출력한다
	apt-cache stats : APT의 전반적인 통계 정보
	apt-cache pkgnames : 사용가능한 전체 패키지의 이름을 보여준다
	apt-cache search [이름] : 패키지 이름 검색하기
	apt-cache show [이름] : 패키지 버전, 패키지 크기, 카테고리 등 패키지에 관한 정보를 확인한다.
	apt-cache showpkg [이름] : 패키지의 설치 여부와 상관없이 패키지의 의존성에 대한 정보를 검색한다.

apt-get : 패키지 저장소를 업데이트하고 패키지를 설치하거나 제거할 수 있다. --> 앞에 sudo를 붙여서 하는 편이 안전하게 설치 가능
	apt-get update : /etc/apt/sources.list에 명시한 저장소로부터 패키지 정보를 읽어 동기화한다. 만약 /etc/apt/sources.list파일을 수정하면 해야한다.
	apt-get upgrade : 현재 설치되어 있는 모든 패키지 중에 새로운 버전이 있는 패키지를 모두 업그레이드한다.
	apt-get install [이름] [추가 설치 이름] : 하나 이상의 패키지를 설치하거나 업그레이드 할 때 사용이 된다.
										   만약 패키지를 설치할 때 업그레이드 하지 않으려면 --no-upgrade
										   새로운 패키지를 설치하지 않고 업그레이드만 할 때는 --only-upgrade 옵션을 사용한다.
	apt-get remove [이름] : 설치되어 있는 패키지를 삭제할 때 사용된다.
	apt-get purge [이름]	: 패키지를 삭제할 때 해당 패키지의 설정 파일을 남겨두기에 설정파일을 포함하여 패키지를 삭제할 때 사용된다.
						  apt-get remove --purge [이름] 형식으로 사용도 가능하다.
	apt-get clean : 내려받은 패키지 파일을 삭제하고 디스크 공간을 정리할 때 사용된다.
	apt-get download [이름] : 패키지를 설치하지 않고 내려받기만 할 때 사용된다 --> 아마 데비안 계열이라 필요는 없지만 혹시나 안될 경우에 쓰는 듯 하다.
		특정 패키지의 소스코드를 내려받기만 하는 경우 : apt-get --download-only source 패키지명
		특정 패키지의 소스 코드를 내려받고 압축을 푸는 경우 : apt-get source 패키지명
		특정 패키지의 소스 코드를 내려받아 압축을 풀고 컴파일하는 경우 : apt-get --compile source 패키지명
	apt-get autoremove : 필요없는 패키지를 삭제한다
	apt-list : 조건에 맞는 패키지 목록을 출력한다.

APT는 인터넷이 연결된 환경에서 패키지를 자동 설치하게 한다 - APT도 내부적으로 dpkg 명령을 사용한다.
dpkg는 데비안 계열의 리눅스에서 패키지를 관리하는 데 사용된다. - 세부패키지 정보를 볼 때 필요하다

dpkg
	dpkg -l : 설치되어 있는 패키지의 목록이 출력된다. 처음 ii는 희망상태(i) 상태(i)를 의미한다.
			  이름을 지정하면 해당 패키지의 정보만 나온다 : dpkg -l [이름]
	dpkg -s [이름] : 패키지의 정보를 상세정보를 확인한다
	dpkg -S [경로명] : 특정 파일이 포함된 패키지 검색하기
	dpkg -L [이름] : 지정한 패키지가 설치한 파일 목록을 검색할 때 사용된다.
	dpkg -c [파일.deb] : .deb파일이 가지고 있는 내용을 출력한다.
	dpkg -i : .deb를 패키지로 설치한다. --> apt-get download로 패키지를 다운 받고 쓸 때 사용하는 것 같다
	dpkg -r, -P [이름] : 패키지를 삭제할 때 -r 혹은 -P를 사용한다.
	dpkg -x [패키지명] : .deb패키지의 내용을 지정한 디렉터리에 풀어 넣는다.

aptitude : APT 명령처럼 자동으로 패키지 관리를 해주며 서브명령없이 실행할 경우 curses를 이용한 비주얼 모드로 작동한다
sudo apt-get install aptitude를 사용해 설치 후 사용이 가능하다
dpkg -l aptitude를 통해 설치 확인이 가능하다 -- 나는 안한다
스냅(snap)은 우분투가 새로 도입한 패키지 형식으로 샌드박스 형태의 패키지다
	샌드박스란 원래 외부에서 받은 파일을 그냥 실행하는 것이 아니라 보호된 영역에서 실행해보는 것으로,
	외부 파일이 내부 시스템에 악영향을 주는 것을 방지하는 보안 기술을 의미한다.
	snap 패키지는 자체적으로 모든 필요한 라이브러리와 의존성을 포함하고 있어, 특정 운영체제에 종속되지 않고 다른 리눅스 배포판에서도 동일하게 작동하도록 설계되어 있다.
사용 시 sudo apt-get install snap으로 설치 후 사용 가능 -- 나는 안함

wsl 네트워크 포워딩
	wsl환경에서 윈도우 호스트의 특정포트로 요청을 하거나 반대로 일 경우 트래픽을 전달하도록 설정하는 작업이다.
	이를 통해서 네트워크 통신을 할 수 있으며, 기본적으로 바로 접근이 불가능한 상황이 있다.
	
	포워딩 방법
	netsh를 사용한 수종 포트 포워딩 - 8080토트를 포워딩한 예시
		규칙 생성 : netsh interface portproxy add v4tov4 listenport=8080 listenaddress=0.0.0.0 connectport=8080 connectaddress=127.0.0.1
		규칙 삭제 : netsh interface portproxy delete v4tov4 listenport=8080 listenaddress=0.0.0.0
		규칙 확인 : netsh interface portproxy show all
		
	방화벽 설정
		규칙 확인 :Get-NetFirewallRule | Where-Object { $_.DisplayName -like "*8080*" }
		규칙 추가 :New-NetFirewallRule -DisplayName "Allow Port 8080" -Direction Inbound -Protocol TCP -LocalPort 8080 -Action Allow
		규칙 삭제 :Remove-NetFirewallRule -DisplayName "Allow Port 8080"
				:Get-NetFirewallRule | Where-Object { $_.LocalPort -eq 8080 } | Remove-NetFirewallRule
		규칙 수정 :Set-NetFirewallRule -DisplayName "Allow Port 8080" -LocalPort 8081

	방화벽 그냥 windows defender 방화벽에 고급설정에서 인바운드 설정으로 하나 8080 허용하는 식으로 연동
	ipconfig로 ip주소를 찾아서 연동하기 예) http://192.168.240.1:8080/api/lists/index


